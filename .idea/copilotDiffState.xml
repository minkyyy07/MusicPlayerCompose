<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/build.gradle.kts">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/build.gradle.kts" />
              <option name="originalContent" value="import org.jetbrains.compose.desktop.application.dsl.TargetFormat&#10;import org.jetbrains.kotlin.gradle.tasks.KotlinCompile&#10;&#10;plugins {&#10;    kotlin(&quot;jvm&quot;) version &quot;1.9.0&quot;&#10;    id(&quot;org.jetbrains.compose&quot;) version &quot;1.5.0&quot;&#10;    kotlin(&quot;plugin.serialization&quot;) version &quot;1.9.0&quot;&#10;}&#10;&#10;group = &quot;com.example.musicplayer&quot;&#10;version = &quot;1.0.0&quot;&#10;&#10;repositories {&#10;    mavenCentral()&#10;    maven(&quot;https://maven.pkg.jetbrains.space/public/p/compose/dev&quot;)&#10;    google()&#10;}&#10;&#10;dependencies {&#10;    // Note: To avoid potential version conflicts, we're using only Compose Desktop dependencies&#10;    // and avoiding AndroidX Compose dependencies in a desktop project&#10;    &#10;    // Compose Desktop&#10;    implementation(compose.desktop.currentOs)&#10;    &#10;    // Material Icons Extended&#10;    implementation(compose.materialIconsExtended)&#10;    &#10;    // Coroutines for Compose Desktop&#10;    implementation(&quot;org.jetbrains.kotlinx:kotlinx-coroutines-core:1.7.3&quot;)&#10;    implementation(&quot;org.jetbrains.kotlinx:kotlinx-coroutines-swing:1.7.3&quot;)&#10;    &#10;    // Image loading for Compose Desktop&#10;    implementation(&quot;io.github.skeptick.libres:libres-compose:1.1.3&quot;)&#10;    &#10;    // Logging&#10;    implementation(&quot;io.github.microutils:kotlin-logging-jvm:3.0.5&quot;)&#10;    implementation(&quot;ch.qos.logback:logback-classic:1.4.8&quot;)&#10;    &#10;    // Ktor for API calls + kotlinx.serialization&#10;    implementation(&quot;io.ktor:ktor-client-cio:2.3.5&quot;)&#10;    implementation(&quot;io.ktor:ktor-client-content-negotiation:2.3.5&quot;)&#10;    implementation(&quot;io.ktor:ktor-serialization-kotlinx-json:2.3.5&quot;)&#10;    implementation(&quot;org.jetbrains.kotlinx:kotlinx-serialization-json:1.6.0&quot;)&#10;&#10;    // MP3 support for audio playback&#10;    implementation(&quot;javazoom:jlayer:1.0.1&quot;)&#10;    implementation(&quot;org.tritonus:tritonus-share:0.3.7-2&quot;)&#10;&#10;    // Alternative: Use JLayer directly for MP3&#10;    implementation(&quot;fr.delthas:javamp3:1.0.3&quot;)&#10;&#10;    // Test&#10;    testImplementation(kotlin(&quot;test&quot;))&#10;    testImplementation(&quot;org.jetbrains.kotlinx:kotlinx-coroutines-test:1.7.3&quot;)&#10;    testImplementation(&quot;io.mockk:mockk:1.13.5&quot;)&#10;}&#10;&#10;tasks.test {&#10;    useJUnitPlatform()&#10;}&#10;&#10;kotlin {&#10;    jvmToolchain(17)&#10;    &#10;    // Enable experimental features&#10;    sourceSets.all {&#10;        languageSettings.apply {&#10;            optIn(&quot;kotlin.RequiresOptIn&quot;)&#10;            languageVersion = &quot;1.9&quot;&#10;        }&#10;    }&#10;}&#10;&#10;tasks.withType&lt;KotlinCompile&gt; {&#10;    kotlinOptions {&#10;        jvmTarget = &quot;17&quot;&#10;        freeCompilerArgs += listOf(&#10;            &quot;-opt-in=kotlin.RequiresOptIn&quot;,&#10;            &quot;-Xjvm-default=all&quot;&#10;        )&#10;    }&#10;}&#10;&#10;compose.desktop {&#10;    application {&#10;        mainClass = &quot;com.example.musicplayer.MainKt&quot;&#10;&#10;        nativeDistributions {&#10;            targetFormats(TargetFormat.Dmg, TargetFormat.Msi, TargetFormat.Deb)&#10;            packageName = &quot;MusicPlayer&quot;&#10;            packageVersion = &quot;1.0.0&quot;&#10;            &#10;            windows {&#10;                menu = true&#10;                upgradeUuid = &quot;123e4567-e89b-12d3-a456-426614174000&quot;&#10;            }&#10;            &#10;            appResourcesRootDir.set(project.layout.projectDirectory.dir(&quot;resources&quot;))&#10;        }&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="import org.jetbrains.compose.desktop.application.dsl.TargetFormat&#10;import org.jetbrains.kotlin.gradle.tasks.KotlinCompile&#10;&#10;plugins {&#10;    kotlin(&quot;jvm&quot;) version &quot;1.9.0&quot;&#10;    id(&quot;org.jetbrains.compose&quot;) version &quot;1.5.0&quot;&#10;    kotlin(&quot;plugin.serialization&quot;) version &quot;1.9.0&quot;&#10;}&#10;&#10;group = &quot;com.example.musicplayer&quot;&#10;version = &quot;1.0.0&quot;&#10;&#10;repositories {&#10;    mavenCentral()&#10;    maven(&quot;https://maven.pkg.jetbrains.space/public/p/compose/dev&quot;)&#10;    google()&#10;}&#10;&#10;dependencies {&#10;    // Note: To avoid potential version conflicts, we're using only Compose Desktop dependencies&#10;    // and avoiding AndroidX Compose dependencies in a desktop project&#10;    &#10;    // Compose Desktop&#10;    implementation(compose.desktop.currentOs)&#10;    &#10;    // Material Icons Extended&#10;    implementation(compose.materialIconsExtended)&#10;    &#10;    // Coroutines for Compose Desktop&#10;    implementation(&quot;org.jetbrains.kotlinx:kotlinx-coroutines-core:1.7.3&quot;)&#10;    implementation(&quot;org.jetbrains.kotlinx:kotlinx-coroutines-swing:1.7.3&quot;)&#10;    &#10;    // Image loading for Compose Desktop&#10;    implementation(&quot;io.github.skeptick.libres:libres-compose:1.1.3&quot;)&#10;    &#10;    // Logging&#10;    implementation(&quot;io.github.microutils:kotlin-logging-jvm:3.0.5&quot;)&#10;    implementation(&quot;ch.qos.logback:logback-classic:1.4.8&quot;)&#10;    &#10;    // Ktor for API calls + kotlinx.serialization&#10;    implementation(&quot;io.ktor:ktor-client-cio:2.3.5&quot;)&#10;    implementation(&quot;io.ktor:ktor-client-content-negotiation:2.3.5&quot;)&#10;    implementation(&quot;io.ktor:ktor-serialization-kotlinx-json:2.3.5&quot;)&#10;    implementation(&quot;org.jetbrains.kotlinx:kotlinx-serialization-json:1.6.0&quot;)&#10;&#10;    // MP3 support for audio playback - только JLayer&#10;    implementation(&quot;javazoom:jlayer:1.0.1&quot;)&#10;&#10;    // Test&#10;    testImplementation(kotlin(&quot;test&quot;))&#10;    testImplementation(&quot;org.jetbrains.kotlinx:kotlinx-coroutines-test:1.7.3&quot;)&#10;    testImplementation(&quot;io.mockk:mockk:1.13.5&quot;)&#10;}&#10;&#10;tasks.test {&#10;    useJUnitPlatform()&#10;}&#10;&#10;kotlin {&#10;    jvmToolchain(17)&#10;    &#10;    // Enable experimental features&#10;    sourceSets.all {&#10;        languageSettings.apply {&#10;            optIn(&quot;kotlin.RequiresOptIn&quot;)&#10;            languageVersion = &quot;1.9&quot;&#10;        }&#10;    }&#10;}&#10;&#10;tasks.withType&lt;KotlinCompile&gt; {&#10;    kotlinOptions {&#10;        jvmTarget = &quot;17&quot;&#10;        freeCompilerArgs += listOf(&#10;            &quot;-opt-in=kotlin.RequiresOptIn&quot;,&#10;            &quot;-Xjvm-default=all&quot;&#10;        )&#10;    }&#10;}&#10;&#10;compose.desktop {&#10;    application {&#10;        mainClass = &quot;com.example.musicplayer.MainKt&quot;&#10;&#10;        nativeDistributions {&#10;            targetFormats(TargetFormat.Dmg, TargetFormat.Msi, TargetFormat.Deb)&#10;            packageName = &quot;MusicPlayer&quot;&#10;            packageVersion = &quot;1.0.0&quot;&#10;            &#10;            windows {&#10;                menu = true&#10;                upgradeUuid = &quot;123e4567-e89b-12d3-a456-426614174000&quot;&#10;            }&#10;            &#10;            appResourcesRootDir.set(project.layout.projectDirectory.dir(&quot;resources&quot;))&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/kotlin/com/example/musicplayer/AppState.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/kotlin/com/example/musicplayer/AppState.kt" />
              <option name="originalContent" value="package com.example.musicplayer&#10;&#10;import androidx.compose.runtime.Composable&#10;import androidx.compose.runtime.Stable&#10;import androidx.compose.runtime.remember&#10;import androidx.compose.runtime.rememberCoroutineScope&#10;import androidx.compose.ui.window.WindowState&#10;import com.example.musicplayer.audio.AdvancedMp3Player&#10;import kotlinx.coroutines.CoroutineScope&#10;import kotlinx.coroutines.Dispatchers&#10;import kotlinx.coroutines.flow.MutableStateFlow&#10;import kotlinx.coroutines.flow.StateFlow&#10;import kotlinx.coroutines.launch&#10;import kotlinx.coroutines.withContext&#10;import java.io.BufferedInputStream&#10;import java.io.File&#10;import java.net.URL&#10;import javax.sound.sampled.AudioSystem&#10;import java.io.FileInputStream&#10;&#10;@Stable&#10;class AppState(&#10;    val windowState: WindowState,&#10;    private val coroutineScope: CoroutineScope&#10;) {&#10;    private val _currentScreen = MutableStateFlow&lt;Screen&gt;(Screen.Player)&#10;    val currentScreen: StateFlow&lt;Screen&gt; = _currentScreen&#10;&#10;    private val _currentTrack = MutableStateFlow&lt;MusicTrack?&gt;(null)&#10;    val currentTrack: StateFlow&lt;MusicTrack?&gt; = _currentTrack&#10;&#10;    private val _isPlaying = MutableStateFlow(false)&#10;    val isPlaying: StateFlow&lt;Boolean&gt; = _isPlaying&#10;&#10;    private val _trackList = MutableStateFlow&lt;List&lt;MusicTrack&gt;&gt;(emptyList())&#10;    val trackList: StateFlow&lt;List&lt;MusicTrack&gt;&gt; = _trackList&#10;&#10;    private var clip: Any? = null&#10;    private val mp3Player = AdvancedMp3Player()&#10;&#10;    // Добавляем доступ к состоянию MP3 плеера&#10;    val playerPosition = mp3Player.position&#10;    val playerDuration = mp3Player.duration&#10;    val playerIsPlaying = mp3Player.isPlaying&#10;&#10;    fun setTrackList(tracks: List&lt;MusicTrack&gt;) {&#10;        _trackList.value = tracks&#10;    }&#10;&#10;    fun navigateTo(screen: Screen) {&#10;        _currentScreen.value = screen&#10;    }&#10;&#10;    fun playPause() {&#10;        try {&#10;            val currentTrack = _currentTrack.value&#10;            if (currentTrack != null &amp;&amp; (currentTrack.filePath.startsWith(&quot;http&quot;) || currentTrack.filePath.lowercase().endsWith(&quot;.mp3&quot;))) {&#10;                // MP3 плеер&#10;                if (mp3Player.isPlaying.value) {&#10;                    mp3Player.pause()&#10;                    _isPlaying.value = false&#10;                } else {&#10;                    mp3Player.play()&#10;                    _isPlaying.value = true&#10;                }&#10;            } else {&#10;                // Стандартный клип для других форматов&#10;                val currentClip = clip as? javax.sound.sampled.Clip&#10;                if (currentClip != null) {&#10;                    if (_isPlaying.value) {&#10;                        currentClip.stop()&#10;                        _isPlaying.value = false&#10;                    } else {&#10;                        currentClip.start()&#10;                        _isPlaying.value = true&#10;                    }&#10;                } else {&#10;                    // Если нет активного плеера, попробуем воспроизвести текущий трек&#10;                    currentTrack?.let { track -&gt;&#10;                        playTrack(track)&#10;                    }&#10;                }&#10;            }&#10;        } catch (e: Exception) {&#10;            println(&quot;Ошибка управления воспроизведением: ${e.message}&quot;)&#10;        }&#10;    }&#10;&#10;    fun seekTo(positionMs: Long) {&#10;        mp3Player.seekTo(positionMs)&#10;    }&#10;&#10;    fun selectTrack(track: MusicTrack) {&#10;        _currentTrack.value = track&#10;        _currentScreen.value = Screen.Player&#10;        playTrack(track)&#10;    }&#10;&#10;    fun playNextTrack() {&#10;        val tracks = _trackList.value&#10;        val currentTrack = _currentTrack.value&#10;        if (tracks.isNotEmpty() &amp;&amp; currentTrack != null) {&#10;            val currentIndex = tracks.indexOf(currentTrack)&#10;            if (currentIndex != -1 &amp;&amp; currentIndex &lt; tracks.size - 1) {&#10;                selectTrack(tracks[currentIndex + 1])&#10;            }&#10;        }&#10;    }&#10;&#10;    fun playPreviousTrack() {&#10;        val tracks = _trackList.value&#10;        val currentTrack = _currentTrack.value&#10;        if (tracks.isNotEmpty() &amp;&amp; currentTrack != null) {&#10;            val currentIndex = tracks.indexOf(currentTrack)&#10;            if (currentIndex &gt; 0) {&#10;                selectTrack(tracks[currentIndex - 1])&#10;            }&#10;        }&#10;    }&#10;&#10;    private fun playTrack(track: MusicTrack) {&#10;        coroutineScope.launch {&#10;            try {&#10;                println(&quot;Попытка воспроизвести трек: ${track.title}&quot;)&#10;                println(&quot;Путь к файлу: ${track.filePath}&quot;)&#10;&#10;                // Остановить предыдущий трек если играет&#10;                stopPlayback()&#10;&#10;                when {&#10;                    track.filePath.startsWith(&quot;http://&quot;) || track.filePath.startsWith(&quot;https://&quot;) -&gt; {&#10;                        println(&quot;Загрузка MP3 по URL...&quot;)&#10;                        if (mp3Player.loadTrack(track.filePath)) {&#10;                            mp3Player.play()&#10;                            _isPlaying.value = true&#10;                            println(&quot;Воспроизведение URL MP3 началось&quot;)&#10;                        } else {&#10;                            throw Exception(&quot;Не удалось загрузить MP3 по URL&quot;)&#10;                        }&#10;                    }&#10;                    track.filePath.lowercase().endsWith(&quot;.mp3&quot;) -&gt; {&#10;                        println(&quot;Загрузка локального MP3 файла...&quot;)&#10;                        if (mp3Player.loadTrack(track.filePath)) {&#10;                            mp3Player.play()&#10;                            _isPlaying.value = true&#10;                            println(&quot;Воспроизведение локального MP3 началось&quot;)&#10;                        } else {&#10;                            throw Exception(&quot;Не удалось загрузить локальный MP3&quot;)&#10;                        }&#10;                    }&#10;                    else -&gt; {&#10;                        println(&quot;Загрузка других форматов...&quot;)&#10;                        val audioFile = File(track.filePath)&#10;                        if (!audioFile.exists()) {&#10;                            throw Exception(&quot;Файл не найден: ${track.filePath}&quot;)&#10;                        }&#10;&#10;                        val audioStream = AudioSystem.getAudioInputStream(audioFile)&#10;                        println(&quot;Аудиопоток получен, создаём клип...&quot;)&#10;                        val newClip = AudioSystem.getClip()&#10;                        newClip.open(audioStream)&#10;&#10;                        println(&quot;Запускаем воспроизведение...&quot;)&#10;                        newClip.start()&#10;                        this@AppState.clip = newClip&#10;                        _isPlaying.value = true&#10;                        println(&quot;Воспроизведение началось успешно!&quot;)&#10;                    }&#10;                }&#10;&#10;            } catch (e: Exception) {&#10;                println(&quot;Ошибка воспроизведения: ${e.message}&quot;)&#10;                e.printStackTrace()&#10;                _isPlaying.value = false&#10;            }&#10;        }&#10;    }&#10;&#10;    fun stopPlayback() {&#10;        try {&#10;            // Остановить MP3 плеер&#10;            mp3Player.stop()&#10;&#10;            // Остановить стандартный клип&#10;            (clip as? javax.sound.sampled.Clip)?.let {&#10;                it.stop()&#10;                it.close()&#10;                clip = null&#10;            }&#10;&#10;            _isPlaying.value = false&#10;        } catch (e: Exception) {&#10;            println(&quot;Ошибка остановки воспроизведения: ${e.message}&quot;)&#10;        }&#10;    }&#10;}&#10;&#10;@Composable&#10;fun rememberAppState(&#10;    windowState: WindowState = WindowState(),&#10;    coroutineScope: CoroutineScope = rememberCoroutineScope()&#10;): AppState {&#10;    return remember(windowState, coroutineScope) {&#10;        AppState(windowState, coroutineScope)&#10;    }&#10;}&#10;&#10;data class MusicTrack(&#10;    val id: Long,&#10;    val title: String,&#10;    val artist: String,&#10;    val album: String,&#10;    val duration: Long,&#10;    val filePath: String,&#10;    val coverArtPath: String? = null&#10;)" />
              <option name="updatedContent" value="package com.example.musicplayer&#10;&#10;import androidx.compose.runtime.Composable&#10;import androidx.compose.runtime.Stable&#10;import androidx.compose.runtime.remember&#10;import androidx.compose.runtime.rememberCoroutineScope&#10;import androidx.compose.ui.window.WindowState&#10;import com.example.musicplayer.audio.SimpleMp3Player&#10;import kotlinx.coroutines.CoroutineScope&#10;import kotlinx.coroutines.Dispatchers&#10;import kotlinx.coroutines.flow.MutableStateFlow&#10;import kotlinx.coroutines.flow.StateFlow&#10;import kotlinx.coroutines.launch&#10;import kotlinx.coroutines.withContext&#10;import java.io.BufferedInputStream&#10;import java.io.File&#10;import java.net.URL&#10;import javax.sound.sampled.AudioSystem&#10;import java.io.FileInputStream&#10;&#10;@Stable&#10;class AppState(&#10;    val windowState: WindowState,&#10;    private val coroutineScope: CoroutineScope&#10;) {&#10;    private val _currentScreen = MutableStateFlow&lt;Screen&gt;(Screen.Player)&#10;    val currentScreen: StateFlow&lt;Screen&gt; = _currentScreen&#10;&#10;    private val _currentTrack = MutableStateFlow&lt;MusicTrack?&gt;(null)&#10;    val currentTrack: StateFlow&lt;MusicTrack?&gt; = _currentTrack&#10;&#10;    private val _isPlaying = MutableStateFlow(false)&#10;    val isPlaying: StateFlow&lt;Boolean&gt; = _isPlaying&#10;&#10;    private val _trackList = MutableStateFlow&lt;List&lt;MusicTrack&gt;&gt;(emptyList())&#10;    val trackList: StateFlow&lt;List&lt;MusicTrack&gt;&gt; = _trackList&#10;&#10;    private var clip: Any? = null&#10;    private val mp3Player = SimpleMp3Player()&#10;&#10;    // Добавляем доступ к состоянию MP3 плеера&#10;    val playerPosition = mp3Player.position&#10;    val playerDuration = mp3Player.duration&#10;    val playerIsPlaying = mp3Player.isPlaying&#10;&#10;    fun setTrackList(tracks: List&lt;MusicTrack&gt;) {&#10;        _trackList.value = tracks&#10;    }&#10;&#10;    fun navigateTo(screen: Screen) {&#10;        _currentScreen.value = screen&#10;    }&#10;&#10;    fun playPause() {&#10;        try {&#10;            val currentTrack = _currentTrack.value&#10;            if (currentTrack != null &amp;&amp; (currentTrack.filePath.startsWith(&quot;http&quot;) || currentTrack.filePath.lowercase().endsWith(&quot;.mp3&quot;))) {&#10;                // MP3 плеер&#10;                if (mp3Player.isPlaying.value) {&#10;                    mp3Player.pause()&#10;                    _isPlaying.value = false&#10;                } else {&#10;                    mp3Player.play()&#10;                    _isPlaying.value = true&#10;                }&#10;            } else {&#10;                // Стандартный клип для других форматов&#10;                val currentClip = clip as? javax.sound.sampled.Clip&#10;                if (currentClip != null) {&#10;                    if (_isPlaying.value) {&#10;                        currentClip.stop()&#10;                        _isPlaying.value = false&#10;                    } else {&#10;                        currentClip.start()&#10;                        _isPlaying.value = true&#10;                    }&#10;                } else {&#10;                    // Если нет активного плеера, попробуем воспроизвести текущий трек&#10;                    currentTrack?.let { track -&gt;&#10;                        playTrack(track)&#10;                    }&#10;                }&#10;            }&#10;        } catch (e: Exception) {&#10;            println(&quot;Ошибка управления воспроизведением: ${e.message}&quot;)&#10;        }&#10;    }&#10;&#10;    fun seekTo(positionMs: Long) {&#10;        mp3Player.seekTo(positionMs)&#10;    }&#10;&#10;    fun selectTrack(track: MusicTrack) {&#10;        _currentTrack.value = track&#10;        _currentScreen.value = Screen.Player&#10;        playTrack(track)&#10;    }&#10;&#10;    fun playNextTrack() {&#10;        val tracks = _trackList.value&#10;        val currentTrack = _currentTrack.value&#10;        if (tracks.isNotEmpty() &amp;&amp; currentTrack != null) {&#10;            val currentIndex = tracks.indexOf(currentTrack)&#10;            if (currentIndex != -1 &amp;&amp; currentIndex &lt; tracks.size - 1) {&#10;                selectTrack(tracks[currentIndex + 1])&#10;            }&#10;        }&#10;    }&#10;&#10;    fun playPreviousTrack() {&#10;        val tracks = _trackList.value&#10;        val currentTrack = _currentTrack.value&#10;        if (tracks.isNotEmpty() &amp;&amp; currentTrack != null) {&#10;            val currentIndex = tracks.indexOf(currentTrack)&#10;            if (currentIndex &gt; 0) {&#10;                selectTrack(tracks[currentIndex - 1])&#10;            }&#10;        }&#10;    }&#10;&#10;    private fun playTrack(track: MusicTrack) {&#10;        coroutineScope.launch {&#10;            try {&#10;                println(&quot;Попытка воспроизвести трек: ${track.title}&quot;)&#10;                println(&quot;Путь к файлу: ${track.filePath}&quot;)&#10;&#10;                // Остановить предыдущий трек если играет&#10;                stopPlayback()&#10;&#10;                when {&#10;                    track.filePath.startsWith(&quot;http://&quot;) || track.filePath.startsWith(&quot;https://&quot;) -&gt; {&#10;                        println(&quot;Загрузка MP3 по URL...&quot;)&#10;                        if (mp3Player.loadTrack(track.filePath)) {&#10;                            mp3Player.play()&#10;                            _isPlaying.value = true&#10;                            println(&quot;Воспроизведение URL MP3 началось&quot;)&#10;                        } else {&#10;                            throw Exception(&quot;Не удалось загрузить MP3 по URL&quot;)&#10;                        }&#10;                    }&#10;                    track.filePath.lowercase().endsWith(&quot;.mp3&quot;) -&gt; {&#10;                        println(&quot;Загрузка локального MP3 файла...&quot;)&#10;                        if (mp3Player.loadTrack(track.filePath)) {&#10;                            mp3Player.play()&#10;                            _isPlaying.value = true&#10;                            println(&quot;Воспроизведение локального MP3 началось&quot;)&#10;                        } else {&#10;                            throw Exception(&quot;Не удалось загрузить локальный MP3&quot;)&#10;                        }&#10;                    }&#10;                    else -&gt; {&#10;                        println(&quot;Загрузка других форматов...&quot;)&#10;                        val audioFile = File(track.filePath)&#10;                        if (!audioFile.exists()) {&#10;                            throw Exception(&quot;Файл не найден: ${track.filePath}&quot;)&#10;                        }&#10;&#10;                        val audioStream = AudioSystem.getAudioInputStream(audioFile)&#10;                        println(&quot;Аудиопоток получен, создаём клип...&quot;)&#10;                        val newClip = AudioSystem.getClip()&#10;                        newClip.open(audioStream)&#10;&#10;                        println(&quot;Запускаем воспроизведение...&quot;)&#10;                        newClip.start()&#10;                        this@AppState.clip = newClip&#10;                        _isPlaying.value = true&#10;                        println(&quot;Воспроизведение началось успешно!&quot;)&#10;                    }&#10;                }&#10;&#10;            } catch (e: Exception) {&#10;                println(&quot;Ошибка воспроизведения: ${e.message}&quot;)&#10;                e.printStackTrace()&#10;                _isPlaying.value = false&#10;            }&#10;        }&#10;    }&#10;&#10;    fun stopPlayback() {&#10;        try {&#10;            // Остановить MP3 плеер&#10;            mp3Player.stop()&#10;&#10;            // Остановить стандартный клип&#10;            (clip as? javax.sound.sampled.Clip)?.let {&#10;                it.stop()&#10;                it.close()&#10;                clip = null&#10;            }&#10;&#10;            _isPlaying.value = false&#10;        } catch (e: Exception) {&#10;            println(&quot;Ошибка остановки воспроизведения: ${e.message}&quot;)&#10;        }&#10;    }&#10;}&#10;&#10;@Composable&#10;fun rememberAppState(&#10;    windowState: WindowState = WindowState(),&#10;    coroutineScope: CoroutineScope = rememberCoroutineScope()&#10;): AppState {&#10;    return remember(windowState, coroutineScope) {&#10;        AppState(windowState, coroutineScope)&#10;    }&#10;}&#10;&#10;data class MusicTrack(&#10;    val id: Long,&#10;    val title: String,&#10;    val artist: String,&#10;    val album: String,&#10;    val duration: Long,&#10;    val filePath: String,&#10;    val coverArtPath: String? = null&#10;)" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/kotlin/com/example/musicplayer/audio/AdvancedMp3Player.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/kotlin/com/example/musicplayer/audio/AdvancedMp3Player.kt" />
              <option name="originalContent" value="package com.example.musicplayer.audio&#10;&#10;import kotlinx.coroutines.*&#10;import kotlinx.coroutines.flow.MutableStateFlow&#10;import kotlinx.coroutines.flow.StateFlow&#10;import java.io.BufferedInputStream&#10;import java.io.File&#10;import java.io.FileInputStream&#10;import java.net.URL&#10;import javazoom.jl.decoder.*&#10;import javazoom.jl.player.AudioDevice&#10;import javazoom.jl.player.FactoryRegistry&#10;import javax.sound.sampled.*&#10;&#10;/**&#10; * Продвинутый MP3 плеер с поддержкой паузы, перемотки и прогресса&#10; */&#10;class AdvancedMp3Player {&#10;    private val _isPlaying = MutableStateFlow(false)&#10;    val isPlaying: StateFlow&lt;Boolean&gt; = _isPlaying&#10;&#10;    private val _position = MutableStateFlow(0L) // позиция в миллисекундах&#10;    val position: StateFlow&lt;Long&gt; = _position&#10;&#10;    private val _duration = MutableStateFlow(0L) // длительность в миллисекундах&#10;    val duration: StateFlow&lt;Long&gt; = _duration&#10;&#10;    private var bitstream: Bitstream? = null&#10;    private var decoder: Decoder? = null&#10;    private var audio: AudioDevice? = null&#10;    private var playbackJob: Job? = null&#10;    private var inputStream: BufferedInputStream? = null&#10;&#10;    private var pausePosition = 0 // позиция в кадрах для возобновления&#10;    private var totalFrames = 0&#10;    private var frameTime = 0L // время одного кадра в мс&#10;&#10;    fun loadTrack(filePath: String): Boolean {&#10;        return try {&#10;            stop()&#10;&#10;            inputStream = when {&#10;                filePath.startsWith(&quot;http://&quot;) || filePath.startsWith(&quot;https://&quot;) -&gt; {&#10;                    BufferedInputStream(URL(filePath).openStream())&#10;                }&#10;                else -&gt; {&#10;                    val file = File(filePath)&#10;                    if (!file.exists()) throw Exception(&quot;Файл не найден: $filePath&quot;)&#10;                    BufferedInputStream(FileInputStream(file))&#10;                }&#10;            }&#10;&#10;            bitstream = Bitstream(inputStream!!)&#10;            decoder = Decoder()&#10;            audio = FactoryRegistry.systemRegistry().createAudioDevice()&#10;&#10;            // Читаем первый кадр для получения информации о формате&#10;            val header = bitstream!!.readFrame() ?: throw Exception(&quot;Не удалось прочитать заголовок&quot;)&#10;            val sampleBuffer = decoder!!.decodeFrame(header, bitstream!!) as SampleBuffer&#10;&#10;            // Инициализируем аудио устройство&#10;            audio!!.open(decoder!!)&#10;&#10;            // Вычисляем приблизительную длительность&#10;            val bitrate = header.bitrate()&#10;            val sampleRate = sampleBuffer.sampleFrequency&#10;            frameTime = (1000L * sampleBuffer.bufferLength) / sampleRate&#10;&#10;            // Возвращаем кадр обратно (упрощение - в реальности нужно переоткрыть поток)&#10;            bitstream!!.closeFrame()&#10;&#10;            resetStream(filePath)&#10;&#10;            pausePosition = 0&#10;            _position.value = 0L&#10;            _duration.value = estimateDuration(filePath, bitrate)&#10;&#10;            true&#10;        } catch (e: Exception) {&#10;            println(&quot;Ошибка загрузки трека: ${e.message}&quot;)&#10;            e.printStackTrace()&#10;            false&#10;        }&#10;    }&#10;&#10;    private fun resetStream(filePath: String) {&#10;        try {&#10;            inputStream?.close()&#10;            bitstream?.close()&#10;&#10;            inputStream = when {&#10;                filePath.startsWith(&quot;http://&quot;) || filePath.startsWith(&quot;https://&quot;) -&gt; {&#10;                    BufferedInputStream(URL(filePath).openStream())&#10;                }&#10;                else -&gt; BufferedInputStream(FileInputStream(File(filePath)))&#10;            }&#10;&#10;            bitstream = Bitstream(inputStream!!)&#10;        } catch (e: Exception) {&#10;            println(&quot;Ошибка перезапуска потока: ${e.message}&quot;)&#10;        }&#10;    }&#10;&#10;    private fun estimateDuration(filePath: String, bitrate: Int): Long {&#10;        return try {&#10;            when {&#10;                filePath.startsWith(&quot;http://&quot;) || filePath.startsWith(&quot;https://&quot;) -&gt; {&#10;                    // Для URL предполагаем 30 секунд (preview)&#10;                    30000L&#10;                }&#10;                else -&gt; {&#10;                    val file = File(filePath)&#10;                    val fileSizeInBytes = file.length()&#10;                    val fileSizeInBits = fileSizeInBytes * 8&#10;                    val durationInSeconds = fileSizeInBits / bitrate&#10;                    durationInSeconds * 1000L&#10;                }&#10;            }&#10;        } catch (e: Exception) {&#10;            30000L // fallback&#10;        }&#10;    }&#10;&#10;    fun play() {&#10;        if (_isPlaying.value) return&#10;&#10;        playbackJob = CoroutineScope(Dispatchers.IO).launch {&#10;            try {&#10;                _isPlaying.value = true&#10;&#10;                // Пропускаем кадры до позиции паузы&#10;                repeat(pausePosition) {&#10;                    val header = bitstream?.readFrame()&#10;                    if (header != null) {&#10;                        bitstream?.closeFrame()&#10;                    }&#10;                }&#10;&#10;                var currentFrame = pausePosition&#10;&#10;                while (_isPlaying.value &amp;&amp; isActive) {&#10;                    val header = bitstream?.readFrame()&#10;                    if (header == null) {&#10;                        // Конец трека&#10;                        break&#10;                    }&#10;&#10;                    try {&#10;                        val output = decoder?.decodeFrame(header, bitstream!!)&#10;                        if (output is SampleBuffer) {&#10;                            val bufferData = output.buffer&#10;                            val bufferLength = output.bufferLength&#10;&#10;                            // Проверяем границы массива перед записью&#10;                            if (bufferData != null &amp;&amp; bufferLength &gt; 0 &amp;&amp; bufferLength &lt;= bufferData.size) {&#10;                                audio?.write(bufferData, 0, bufferLength)&#10;                                currentFrame++&#10;&#10;                                // Обновляем позицию&#10;                                _position.value = currentFrame * frameTime&#10;                            } else {&#10;                                println(&quot;Предупреждение: неверный размер буфера: $bufferLength/${bufferData?.size}&quot;)&#10;                            }&#10;                        }&#10;                    } catch (e: Exception) {&#10;                        println(&quot;Ошибка декодирования кадра: ${e.message}&quot;)&#10;                        // Продолжаем со следующим кадром&#10;                    }&#10;&#10;                    bitstream?.closeFrame()&#10;&#10;                    // Небольшая задержка для предотвращения перегрузки CPU&#10;                    delay(10) // Увеличиваем задержку для стабильности&#10;                }&#10;&#10;                pausePosition = currentFrame&#10;&#10;            } catch (e: Exception) {&#10;                println(&quot;Ошибка воспроизведения: ${e.message}&quot;)&#10;                e.printStackTrace()&#10;            } finally {&#10;                _isPlaying.value = false&#10;            }&#10;        }&#10;    }&#10;&#10;    fun pause() {&#10;        _isPlaying.value = false&#10;        playbackJob?.cancel()&#10;    }&#10;&#10;    fun stop() {&#10;        _isPlaying.value = false&#10;        playbackJob?.cancel()&#10;&#10;        try {&#10;            audio?.close()&#10;            bitstream?.close()&#10;            inputStream?.close()&#10;        } catch (e: Exception) {&#10;            println(&quot;Ошибка остановки: ${e.message}&quot;)&#10;        }&#10;&#10;        pausePosition = 0&#10;        _position.value = 0L&#10;    }&#10;&#10;    fun seekTo(positionMs: Long) {&#10;        val targetFrame = (positionMs / frameTime).toInt()&#10;        pausePosition = targetFrame.coerceAtLeast(0)&#10;        _position.value = pausePosition * frameTime&#10;&#10;        // Если играет, перезапускаем с новой позиции&#10;        if (_isPlaying.value) {&#10;            pause()&#10;            // Небольшая задержка перед возобновлением&#10;            CoroutineScope(Dispatchers.Main).launch {&#10;                delay(100)&#10;                play()&#10;            }&#10;        }&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.example.musicplayer.audio&#10;&#10;import kotlinx.coroutines.*&#10;import kotlinx.coroutines.flow.MutableStateFlow&#10;import kotlinx.coroutines.flow.StateFlow&#10;import java.io.BufferedInputStream&#10;import java.io.File&#10;import java.io.FileInputStream&#10;import java.net.URL&#10;import javazoom.jl.player.Player&#10;&#10;/**&#10; * Упрощенный MP3 плеер для стабильного воспроизведения&#10; */&#10;class SimpleMp3Player {&#10;    private val _isPlaying = MutableStateFlow(false)&#10;    val isPlaying: StateFlow&lt;Boolean&gt; = _isPlaying&#10;&#10;    private val _position = MutableStateFlow(0L) // позиция в миллисекундах&#10;    val position: StateFlow&lt;Long&gt; = _position&#10;&#10;    private val _duration = MutableStateFlow(0L) // длительность в миллисекундах&#10;    val duration: StateFlow&lt;Long&gt; = _duration&#10;&#10;    private var player: Player? = null&#10;    private var playbackJob: Job? = null&#10;    private var startTime = 0L&#10;    private var pausedPosition = 0L&#10;    private var currentFilePath: String? = null&#10;&#10;    fun loadTrack(filePath: String): Boolean {&#10;        return try {&#10;            stop()&#10;            currentFilePath = filePath&#10;&#10;            // Устанавливаем примерную длительность&#10;            _duration.value = when {&#10;                filePath.startsWith(&quot;http://&quot;) || filePath.startsWith(&quot;https://&quot;) -&gt; 30000L // 30 сек для preview&#10;                else -&gt; {&#10;                    try {&#10;                        val file = File(filePath)&#10;                        if (file.exists()) {&#10;                            // Приблизительная оценка по размеру файла (128 kbps)&#10;                            val fileSizeBytes = file.length()&#10;                            val estimatedDurationMs = (fileSizeBytes * 8) / (128 * 1000 / 8) * 1000&#10;                            estimatedDurationMs&#10;                        } else {&#10;                            30000L&#10;                        }&#10;                    } catch (e: Exception) {&#10;                        30000L&#10;                    }&#10;                }&#10;            }&#10;&#10;            _position.value = 0L&#10;            pausedPosition = 0L&#10;&#10;            true&#10;        } catch (e: Exception) {&#10;            println(&quot;Ошибка загрузки трека: ${e.message}&quot;)&#10;            false&#10;        }&#10;    }&#10;&#10;    fun play() {&#10;        if (_isPlaying.value) return&#10;&#10;        val filePath = currentFilePath ?: return&#10;&#10;        playbackJob = CoroutineScope(Dispatchers.IO).launch {&#10;            try {&#10;                _isPlaying.value = true&#10;                startTime = System.currentTimeMillis() - pausedPosition&#10;&#10;                // Создаем новый плеер&#10;                val inputStream = when {&#10;                    filePath.startsWith(&quot;http://&quot;) || filePath.startsWith(&quot;https://&quot;) -&gt; {&#10;                        BufferedInputStream(URL(filePath).openStream())&#10;                    }&#10;                    else -&gt; {&#10;                        val file = File(filePath)&#10;                        if (!file.exists()) throw Exception(&quot;Файл не найден: $filePath&quot;)&#10;                        BufferedInputStream(FileInputStream(file))&#10;                    }&#10;                }&#10;&#10;                player = Player(inputStream)&#10;&#10;                // Обновляем позицию во время воспроизведения&#10;                val positionUpdateJob = launch {&#10;                    while (_isPlaying.value &amp;&amp; isActive) {&#10;                        val elapsed = System.currentTimeMillis() - startTime&#10;                        _position.value = elapsed.coerceAtMost(_duration.value)&#10;                        delay(100) // Обновляем каждые 100мс&#10;                    }&#10;                }&#10;&#10;                // Воспроизведение (блокирующий вызов)&#10;                player?.play()&#10;&#10;                positionUpdateJob.cancel()&#10;&#10;            } catch (e: Exception) {&#10;                println(&quot;Ошибка воспроизведения: ${e.message}&quot;)&#10;            } finally {&#10;                _isPlaying.value = false&#10;            }&#10;        }&#10;    }&#10;&#10;    fun pause() {&#10;        pausedPosition = _position.value&#10;        stop()&#10;    }&#10;&#10;    fun stop() {&#10;        _isPlaying.value = false&#10;        playbackJob?.cancel()&#10;&#10;        try {&#10;            player?.close()&#10;            player = null&#10;        } catch (e: Exception) {&#10;            println(&quot;Ошибка остановки: ${e.message}&quot;)&#10;        }&#10;    }&#10;&#10;    fun seekTo(positionMs: Long) {&#10;        // Для упрощения - перезапускаем трек с начала&#10;        // В реальном плеере нужно более сложное seeking&#10;        pausedPosition = 0L&#10;        _position.value = 0L&#10;&#10;        if (_isPlaying.value) {&#10;            stop()&#10;            // Небольшая задержка перед перезапуском&#10;            CoroutineScope(Dispatchers.Main).launch {&#10;                delay(200)&#10;                play()&#10;            }&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/kotlin/com/example/musicplayer/data/deezer/DeezerApi.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/kotlin/com/example/musicplayer/data/deezer/DeezerApi.kt" />
              <option name="updatedContent" value="package com.example.musicplayer.data.deezer&#10;&#10;import com.example.musicplayer.MusicTrack as AppMusicTrack&#10;import io.ktor.client.*&#10;import io.ktor.client.call.*&#10;import io.ktor.client.engine.cio.*&#10;import io.ktor.client.plugins.contentnegotiation.*&#10;import io.ktor.client.request.*&#10;import io.ktor.serialization.kotlinx.json.*&#10;import kotlinx.serialization.SerialName&#10;import kotlinx.serialization.Serializable&#10;import kotlinx.serialization.json.Json&#10;import java.net.URLEncoder&#10;import java.nio.charset.StandardCharsets&#10;&#10;/**&#10; * Поиск треков через Deezer API (публичный, без ключа для базовых запросов).&#10; * Документация: https://developers.deezer.com/api/search&#10; * Замечание: preview (30 сек) доступен в поле preview.&#10; */&#10;object DeezerApi {&#10;    private val json = Json { ignoreUnknownKeys = true }&#10;&#10;    private val client: HttpClient by lazy {&#10;        HttpClient(CIO) {&#10;            install(ContentNegotiation) { json(json) }&#10;        }&#10;    }&#10;&#10;    suspend fun searchTracks(query: String, limit: Int = 25): List&lt;DeezerTrack&gt; {&#10;        if (query.isBlank()) return emptyList()&#10;        val encoded = URLEncoder.encode(query.trim(), StandardCharsets.UTF_8)&#10;        val url = &quot;https://api.deezer.com/search?q=$encoded&amp;limit=$limit&quot;&#10;        val response: DeezerSearchResponse = client.get(url).body()&#10;        return response.data&#10;    }&#10;}&#10;&#10;@Serializable&#10;data class DeezerSearchResponse(&#10;    @SerialName(&quot;data&quot;) val data: List&lt;DeezerTrack&gt; = emptyList(),&#10;    @SerialName(&quot;total&quot;) val total: Int? = null,&#10;    @SerialName(&quot;next&quot;) val next: String? = null&#10;)&#10;&#10;@Serializable&#10;data class DeezerTrack(&#10;    @SerialName(&quot;id&quot;) val id: Long,&#10;    @SerialName(&quot;title&quot;) val title: String? = null,&#10;    @SerialName(&quot;duration&quot;) val durationSec: Long? = null,&#10;    @SerialName(&quot;preview&quot;) val previewUrl: String? = null,&#10;    @SerialName(&quot;artist&quot;) val artist: DeezerArtist? = null,&#10;    @SerialName(&quot;album&quot;) val album: DeezerAlbum? = null&#10;)&#10;&#10;@Serializable&#10;data class DeezerArtist(@SerialName(&quot;name&quot;) val name: String? = null)&#10;&#10;@Serializable&#10;data class DeezerAlbum(&#10;    @SerialName(&quot;title&quot;) val title: String? = null,&#10;    @SerialName(&quot;cover_medium&quot;) val coverMedium: String? = null,&#10;    @SerialName(&quot;cover_big&quot;) val coverBig: String? = null&#10;)&#10;&#10;// Маппер в доменную модель&#10;fun DeezerTrack.toAppMusicTrack(): AppMusicTrack = AppMusicTrack(&#10;    id = id,&#10;    title = title ?: &quot;Unknown&quot;,&#10;    artist = artist?.name ?: &quot;Unknown&quot;,&#10;    album = album?.title ?: &quot;&quot;,&#10;    duration = (durationSec ?: 0L) * 1000L,&#10;    filePath = previewUrl ?: &quot;&quot;,&#10;    coverArtPath = album?.coverBig ?: album?.coverMedium&#10;)&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/kotlin/com/example/musicplayer/data/itunes/ITunesApi.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/kotlin/com/example/musicplayer/data/itunes/ITunesApi.kt" />
              <option name="originalContent" value="package com.example.musicplayer.data.itunes&#10;&#10;import io.ktor.client.*&#10;import io.ktor.client.call.*&#10;import io.ktor.client.engine.cio.*&#10;import io.ktor.client.plugins.contentnegotiation.*&#10;import io.ktor.client.request.*&#10;import io.ktor.serialization.kotlinx.json.*&#10;import kotlinx.serialization.SerialName&#10;import kotlinx.serialization.Serializable&#10;import kotlinx.serialization.json.Json&#10;import java.net.URLEncoder&#10;import java.nio.charset.StandardCharsets&#10;&#10;/**&#10; * Простое обращение к iTunes Search API (без ключа)&#10; * Документация: https://developer.apple.com/library/archive/documentation/AudioVideo/Conceptual/iTuneSearchAPI/&#10; */&#10;object ITunesApi {&#10;    private val json = Json { ignoreUnknownKeys = true }&#10;&#10;    private val client: HttpClient by lazy {&#10;        HttpClient(CIO) {&#10;            install(ContentNegotiation) { json(json) }&#10;        }&#10;    }&#10;&#10;    suspend fun searchTracks(term: String, limit: Int = 25, country: String = &quot;US&quot;): List&lt;ITunesTrack&gt; {&#10;        if (term.isBlank()) return emptyList()&#10;        val encoded = URLEncoder.encode(term.trim(), StandardCharsets.UTF_8)&#10;        val url = &quot;https://itunes.apple.com/search?term=$encoded&amp;entity=song&amp;limit=$limit&amp;country=$country&quot;&#10;        val response: ITunesSearchResponse = client.get(url).body()&#10;        return response.results&#10;    }&#10;}&#10;&#10;@Serializable&#10;data class ITunesSearchResponse(&#10;    @SerialName(&quot;resultCount&quot;) val resultCount: Int = 0,&#10;    @SerialName(&quot;results&quot;) val results: List&lt;ITunesTrack&gt; = emptyList()&#10;)&#10;&#10;@Serializable&#10;data class ITunesTrack(&#10;    @SerialName(&quot;trackId&quot;) val trackId: Long? = null,&#10;    @SerialName(&quot;trackName&quot;) val trackName: String? = null,&#10;    @SerialName(&quot;artistName&quot;) val artistName: String? = null,&#10;    @SerialName(&quot;collectionName&quot;) val collectionName: String? = null,&#10;    @SerialName(&quot;previewUrl&quot;) val previewUrl: String? = null,&#10;    @SerialName(&quot;artworkUrl100&quot;) val artworkUrl100: String? = null,&#10;    @SerialName(&quot;trackTimeMillis&quot;) val trackTimeMillis: Long? = null&#10;)&#10;&#10;// Маппер в доменную модель приложения (используем MusicTrack из корневого пакета)&#10;import com.example.musicplayer.MusicTrack as AppMusicTrack&#10;&#10;fun ITunesTrack.toAppMusicTrack(): AppMusicTrack = AppMusicTrack(&#10;    id = trackId ?: 0L,&#10;    title = trackName ?: &quot;Unknown&quot;,&#10;    artist = artistName ?: &quot;Unknown&quot;,&#10;    album = collectionName ?: &quot;&quot;,&#10;    duration = trackTimeMillis ?: 0L,&#10;    filePath = previewUrl ?: &quot;&quot;, // пока только превью URL (30 сек)&#10;    coverArtPath = artworkUrl100&#10;)&#10;&#10;" />
              <option name="updatedContent" value="package com.example.musicplayer.data.itunes&#10;&#10;import com.example.musicplayer.MusicTrack as AppMusicTrack&#10;import io.ktor.client.*&#10;import io.ktor.client.call.*&#10;import io.ktor.client.engine.cio.*&#10;import io.ktor.client.plugins.contentnegotiation.*&#10;import io.ktor.client.request.*&#10;import io.ktor.serialization.kotlinx.json.*&#10;import java.net.URLEncoder&#10;import java.nio.charset.StandardCharsets&#10;import kotlinx.serialization.SerialName&#10;import kotlinx.serialization.Serializable&#10;import kotlinx.serialization.json.Json&#10;&#10;/**&#10; * Простое обращение к iTunes Search API (без ключа)&#10; * Документация: https://developer.apple.com/library/archive/documentation/AudioVideo/Conceptual/iTuneSearchAPI/&#10; */&#10;object ITunesApi {&#10;    private val json = Json { ignoreUnknownKeys = true }&#10;&#10;    private val client: HttpClient by lazy {&#10;        HttpClient(CIO) {&#10;            install(ContentNegotiation) { json(json) }&#10;        }&#10;    }&#10;&#10;    suspend fun searchTracks(term: String, limit: Int = 25, country: String = &quot;US&quot;): List&lt;ITunesTrack&gt; {&#10;        if (term.isBlank()) return emptyList()&#10;        val encoded = URLEncoder.encode(term.trim(), StandardCharsets.UTF_8)&#10;        val url = &quot;https://itunes.apple.com/search?term=$encoded&amp;entity=song&amp;limit=$limit&amp;country=$country&quot;&#10;        val response: ITunesSearchResponse = client.get(url).body()&#10;        return response.results&#10;    }&#10;}&#10;&#10;@Serializable&#10;data class ITunesSearchResponse(&#10;    @SerialName(&quot;resultCount&quot;) val resultCount: Int = 0,&#10;    @SerialName(&quot;results&quot;) val results: List&lt;ITunesTrack&gt; = emptyList()&#10;)&#10;&#10;@Serializable&#10;data class ITunesTrack(&#10;    @SerialName(&quot;trackId&quot;) val trackId: Long? = null,&#10;    @SerialName(&quot;trackName&quot;) val trackName: String? = null,&#10;    @SerialName(&quot;artistName&quot;) val artistName: String? = null,&#10;    @SerialName(&quot;collectionName&quot;) val collectionName: String? = null,&#10;    @SerialName(&quot;previewUrl&quot;) val previewUrl: String? = null,&#10;    @SerialName(&quot;artworkUrl100&quot;) val artworkUrl100: String? = null,&#10;    @SerialName(&quot;trackTimeMillis&quot;) val trackTimeMillis: Long? = null&#10;)&#10;&#10;// Маппер&#10;fun ITunesTrack.toAppMusicTrack(): AppMusicTrack = AppMusicTrack(&#10;    id = trackId ?: 0L,&#10;    title = trackName ?: &quot;Unknown&quot;,&#10;    artist = artistName ?: &quot;Unknown&quot;,&#10;    album = collectionName ?: &quot;&quot;,&#10;    duration = trackTimeMillis ?: 0L,&#10;    filePath = previewUrl ?: &quot;&quot;,&#10;    coverArtPath = artworkUrl100&#10;)" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/kotlin/com/example/musicplayer/ui/components/AlbumCover.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/kotlin/com/example/musicplayer/ui/components/AlbumCover.kt" />
              <option name="originalContent" value="package com.example.musicplayer.ui.components&#10;&#10;import androidx.compose.foundation.Image&#10;import androidx.compose.foundation.background&#10;import androidx.compose.foundation.layout.Box&#10;import androidx.compose.foundation.layout.fillMaxSize&#10;import androidx.compose.material.MaterialTheme&#10;import androidx.compose.material.Text&#10;import androidx.compose.runtime.*&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.draw.clip&#10;import androidx.compose.ui.graphics.ImageBitmap&#10;import androidx.compose.ui.graphics.asImageBitmap&#10;import androidx.compose.ui.layout.ContentScale&#10;import com.example.musicplayer.MusicTrack&#10;import kotlinx.coroutines.Dispatchers&#10;import kotlinx.coroutines.withContext&#10;import java.awt.image.BufferedImage&#10;import java.io.ByteArrayOutputStream&#10;import java.io.File&#10;import java.net.URL&#10;import javax.imageio.ImageIO&#10;import org.jetbrains.skia.Image as SkiaImage&#10;&#10;@Composable&#10;fun AlbumCover(track: MusicTrack, modifier: Modifier = Modifier) {&#10;    var imageBitmap by remember(track.coverArtPath) { mutableStateOf&lt;ImageBitmap?&gt;(null) }&#10;    var loadError by remember(track.coverArtPath) { mutableStateOf(false) }&#10;&#10;    LaunchedEffect(track.coverArtPath) {&#10;        val path = track.coverArtPath&#10;        if (path.isNullOrBlank()) {&#10;            loadError = true&#10;            return@LaunchedEffect&#10;        }&#10;        val buffered = withContext(Dispatchers.IO) {&#10;            runCatching {&#10;                when {&#10;                    path.startsWith(&quot;http://&quot;) || path.startsWith(&quot;https://&quot;) -&gt; ImageIO.read(URL(path))&#10;                    else -&gt; ImageIO.read(File(path))&#10;                }&#10;            }.getOrNull()&#10;        }&#10;        if (buffered != null) {&#10;            imageBitmap = buffered.toImageBitmap()&#10;        } else {&#10;            loadError = true&#10;        }&#10;    }&#10;&#10;    Box(&#10;        modifier = modifier&#10;            .clip(MaterialTheme.shapes.large)&#10;            .background(MaterialTheme.colors.primary.copy(alpha = 0.2f)),&#10;        contentAlignment = Alignment.Center&#10;    ) {&#10;        when {&#10;            imageBitmap != null -&gt; Image(&#10;                bitmap = imageBitmap!!,&#10;                contentDescription = &quot;${track.album} cover&quot;,&#10;                contentScale = ContentScale.Crop,&#10;                modifier = Modifier.fillMaxSize()&#10;            )&#10;            loadError -&gt; Text(&#10;                text = track.title.take(2).uppercase(),&#10;                style = MaterialTheme.typography.h3,&#10;                color = MaterialTheme.colors.primary&#10;            )&#10;            else -&gt; Text(&#10;                text = &quot;…&quot;,&#10;                style = MaterialTheme.typography.h4,&#10;                color = MaterialTheme.colors.primary&#10;            )&#10;        }&#10;    }&#10;}&#10;&#10;private fun BufferedImage.toImageBitmap(): ImageBitmap {&#10;    val baos = ByteArrayOutputStream()&#10;    ImageIO.write(this, &quot;png&quot;, baos)&#10;    return SkiaImage.makeFromEncoded(baos.toByteArray()).toComposeImageBitmap()&#10;}&#10;" />
              <option name="updatedContent" value="package com.example.musicplayer.ui.components&#10;&#10;import androidx.compose.foundation.Image&#10;import androidx.compose.foundation.background&#10;import androidx.compose.foundation.layout.Box&#10;import androidx.compose.foundation.layout.fillMaxSize&#10;import androidx.compose.material.MaterialTheme&#10;import androidx.compose.material.Text&#10;import androidx.compose.runtime.*&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.draw.clip&#10;import androidx.compose.ui.graphics.ImageBitmap&#10;import androidx.compose.ui.graphics.asImageBitmap&#10;import androidx.compose.ui.layout.ContentScale&#10;import com.example.musicplayer.MusicTrack&#10;import kotlinx.coroutines.Dispatchers&#10;import kotlinx.coroutines.withContext&#10;import java.awt.image.BufferedImage&#10;import java.io.ByteArrayOutputStream&#10;import java.io.File&#10;import java.net.URL&#10;import javax.imageio.ImageIO&#10;import org.jetbrains.skia.Image as SkiaImage&#10;&#10;@Composable&#10;fun AlbumCover(track: MusicTrack, modifier: Modifier = Modifier) {&#10;    var imageBitmap by remember(track.coverArtPath) { mutableStateOf&lt;ImageBitmap?&gt;(null) }&#10;    var loadError by remember(track.coverArtPath) { mutableStateOf(false) }&#10;&#10;    LaunchedEffect(track.coverArtPath) {&#10;        val path = track.coverArtPath&#10;        if (path.isNullOrBlank()) {&#10;            loadError = true&#10;            return@LaunchedEffect&#10;        }&#10;        val buffered = withContext(Dispatchers.IO) {&#10;            runCatching {&#10;                when {&#10;                    path.startsWith(&quot;http://&quot;) || path.startsWith(&quot;https://&quot;) -&gt; ImageIO.read(URL(path))&#10;                    else -&gt; ImageIO.read(File(path))&#10;                }&#10;            }.getOrNull()&#10;        }&#10;        if (buffered != null) {&#10;            imageBitmap = buffered.toImageBitmap()&#10;        } else {&#10;            loadError = true&#10;        }&#10;    }&#10;&#10;    Box(&#10;        modifier = modifier&#10;            .clip(MaterialTheme.shapes.large)&#10;            .background(MaterialTheme.colors.primary.copy(alpha = 0.2f)),&#10;        contentAlignment = Alignment.Center&#10;    ) {&#10;        when {&#10;            imageBitmap != null -&gt; Image(&#10;                bitmap = imageBitmap!!,&#10;                contentDescription = &quot;${track.album} cover&quot;,&#10;                contentScale = ContentScale.Crop,&#10;                modifier = Modifier.fillMaxSize()&#10;            )&#10;            loadError -&gt; Text(&#10;                text = track.title.take(2).uppercase(),&#10;                style = MaterialTheme.typography.h3,&#10;                color = MaterialTheme.colors.primary&#10;            )&#10;            else -&gt; Text(&#10;                text = &quot;…&quot;,&#10;                style = MaterialTheme.typography.h4,&#10;                color = MaterialTheme.colors.primary&#10;            )&#10;        }&#10;    }&#10;}&#10;&#10;private fun BufferedImage.toImageBitmap(): ImageBitmap {&#10;    @Suppress(&quot;DEPRECATION&quot;)&#10;    val baos = ByteArrayOutputStream()&#10;    ImageIO.write(this, &quot;png&quot;, baos)&#10;    return SkiaImage.makeFromEncoded(baos.toByteArray()).asImageBitmap()&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/kotlin/com/example/musicplayer/ui/components/PlaybackProgressBar.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/kotlin/com/example/musicplayer/ui/components/PlaybackProgressBar.kt" />
              <option name="originalContent" value="package com.example.musicplayer.ui.components&#10;&#10;import androidx.compose.foundation.layout.*&#10;import androidx.compose.material.*&#10;import androidx.compose.runtime.*&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.unit.dp&#10;&#10;@Composable&#10;fun PlaybackProgressBar(&#10;    currentPosition: Float,&#10;    duration: Float,&#10;    onPositionChange: (Float) -&gt; Unit&#10;) {&#10;    Column(modifier = Modifier.fillMaxWidth().padding(horizontal = 16.dp)) {&#10;        Slider(&#10;            value = currentPosition,&#10;            onValueChange = onPositionChange,&#10;            valueRange = 0f..duration.coerceAtLeast(1f),&#10;            colors = SliderDefaults.colors(thumbColor = MaterialTheme.colors.primary)&#10;        )&#10;&#10;        Row(&#10;            modifier = Modifier.fillMaxWidth(),&#10;            horizontalArrangement = Arrangement.SpaceBetween&#10;        ) {&#10;            Text(&#10;                text = formatTime(currentPosition.toInt()),&#10;                style = MaterialTheme.typography.caption&#10;            )&#10;            Text(&#10;                text = formatTime(duration.toInt()),&#10;                style = MaterialTheme.typography.caption&#10;            )&#10;        }&#10;    }&#10;}&#10;&#10;private fun formatTime(seconds: Int): String {&#10;    val minutes = seconds / 60&#10;    val remainingSeconds = seconds % 60&#10;    return &quot;%d:%02d&quot;.format(minutes, remainingSeconds)&#10;}" />
              <option name="updatedContent" value="package com.example.musicplayer.ui.components&#10;&#10;import androidx.compose.foundation.layout.*&#10;import androidx.compose.material.*&#10;import androidx.compose.runtime.*&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.unit.dp&#10;&#10;@Composable&#10;fun PlaybackProgressBar(&#10;    currentPosition: Float,&#10;    duration: Float,&#10;    onPositionChange: (Float) -&gt; Unit,&#10;    onSeek: ((Float) -&gt; Unit)? = null&#10;) {&#10;    Column(modifier = Modifier.fillMaxWidth().padding(horizontal = 16.dp)) {&#10;        Slider(&#10;            value = if (duration &gt; 0) currentPosition.coerceIn(0f, duration) else 0f,&#10;            onValueChange = { newValue -&gt;&#10;                onPositionChange(newValue)&#10;                onSeek?.invoke(newValue)&#10;            },&#10;            valueRange = 0f..duration.coerceAtLeast(1f),&#10;            colors = SliderDefaults.colors(&#10;                thumbColor = MaterialTheme.colors.primary,&#10;                activeTrackColor = MaterialTheme.colors.primary,&#10;                inactiveTrackColor = MaterialTheme.colors.onBackground.copy(alpha = 0.3f)&#10;            )&#10;        )&#10;&#10;        Row(&#10;            modifier = Modifier.fillMaxWidth(),&#10;            horizontalArrangement = Arrangement.SpaceBetween&#10;        ) {&#10;            Text(&#10;                text = formatTime(currentPosition.toInt()),&#10;                style = MaterialTheme.typography.caption,&#10;                color = MaterialTheme.colors.onBackground.copy(alpha = 0.7f)&#10;            )&#10;            Text(&#10;                text = formatTime(duration.toInt()),&#10;                style = MaterialTheme.typography.caption,&#10;                color = MaterialTheme.colors.onBackground.copy(alpha = 0.7f)&#10;            )&#10;        }&#10;    }&#10;}&#10;&#10;private fun formatTime(seconds: Int): String {&#10;    val minutes = seconds / 60&#10;    val remainingSeconds = seconds % 60&#10;    return &quot;%d:%02d&quot;.format(minutes, remainingSeconds)&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/kotlin/com/example/musicplayer/ui/components/TrackItem.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/kotlin/com/example/musicplayer/ui/components/TrackItem.kt" />
              <option name="originalContent" value="package com.example.musicplayer.ui.components&#10;&#10;import androidx.compose.foundation.clickable&#10;import androidx.compose.foundation.layout.*&#10;import androidx.compose.material.Icon&#10;import androidx.compose.material.MaterialTheme&#10;import androidx.compose.material.Text&#10;import androidx.compose.material.icons.Icons&#10;import androidx.compose.material.icons.filled.MusicNote&#10;import androidx.compose.runtime.Composable&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.text.style.TextOverflow&#10;import androidx.compose.ui.unit.dp&#10;import com.example.musicplayer.MusicTrack&#10;&#10;@Composable&#10;fun TrackItem(&#10;    track: MusicTrack,&#10;    onClick: () -&gt; Unit,&#10;    modifier: Modifier = Modifier&#10;) {&#10;    Row(&#10;        modifier = modifier&#10;            .fillMaxWidth()&#10;            .clickable(onClick = onClick)&#10;            .padding(vertical = 8.dp, horizontal = 16.dp),&#10;        verticalAlignment = Alignment.CenterVertically&#10;    ) {&#10;        Icon(&#10;            imageVector = Icons.Default.MusicNote,&#10;            contentDescription = null,&#10;            tint = MaterialTheme.colors.primary&#10;        )&#10;&#10;        Spacer(modifier = Modifier.width(16.dp))&#10;&#10;        Column(modifier = Modifier.weight(1f)) {&#10;            Text(&#10;                text = track.title,&#10;                style = MaterialTheme.typography.body1,&#10;                maxLines = 1,&#10;                overflow = TextOverflow.Ellipsis&#10;            )&#10;&#10;            Row(&#10;                Text(&#10;                    text = track.artist,&#10;                    style = MaterialTheme.typography.body2,&#10;                    color = MaterialTheme.colors.onBackground.copy(alpha = 0,7),&#10;                    maxLines = 1,&#10;                    overflow = TextOverflow.Ellipsis&#10;                )&#10;&#10;                        Text(&#10;                        text = &quot; • ${track.album}&quot;,&#10;                style = MaterialTheme.typography.body2,&#10;                color = MaterialTheme.colors.onBackground.copy(alpha = 0.5f),&#10;                maxLines = 1,&#10;                overflow = TextOverflow.Ellipsis&#10;            )&#10;            )&#10;        }&#10;    }&#10;}" />
              <option name="updatedContent" value="package com.example.musicplayer.ui.components&#10;&#10;import androidx.compose.foundation.clickable&#10;import androidx.compose.foundation.layout.*&#10;import androidx.compose.material.Icon&#10;import androidx.compose.material.MaterialTheme&#10;import androidx.compose.material.Text&#10;import androidx.compose.material.icons.Icons&#10;import androidx.compose.material.icons.filled.MusicNote&#10;import androidx.compose.runtime.Composable&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.text.style.TextOverflow&#10;import androidx.compose.ui.unit.dp&#10;import com.example.musicplayer.MusicTrack&#10;&#10;@Composable&#10;fun TrackItem(&#10;    track: MusicTrack,&#10;    onClick: () -&gt; Unit,&#10;    modifier: Modifier = Modifier&#10;) {&#10;    Row(&#10;        modifier = modifier&#10;            .fillMaxWidth()&#10;            .clickable(onClick = onClick)&#10;            .padding(vertical = 8.dp, horizontal = 16.dp),&#10;        verticalAlignment = Alignment.CenterVertically&#10;    ) {&#10;        Icon(&#10;            imageVector = Icons.Default.MusicNote,&#10;            contentDescription = null,&#10;            tint = MaterialTheme.colors.primary&#10;        )&#10;&#10;        Spacer(modifier = Modifier.width(16.dp))&#10;&#10;        Column(modifier = Modifier.weight(1f)) {&#10;            Text(&#10;                text = track.title,&#10;                style = MaterialTheme.typography.body1,&#10;                maxLines = 1,&#10;                overflow = TextOverflow.Ellipsis&#10;            )&#10;&#10;            Row(verticalAlignment = Alignment.CenterVertically) {&#10;                Text(&#10;                    text = track.artist,&#10;                    style = MaterialTheme.typography.body2,&#10;                    color = MaterialTheme.colors.onBackground.copy(alpha = 0.7f),&#10;                    maxLines = 1,&#10;                    overflow = TextOverflow.Ellipsis&#10;                )&#10;                if (!track.album.isNullOrBlank()) {&#10;                    Spacer(modifier = Modifier.width(4.dp))&#10;                    Text(&#10;                        text = &quot;• ${track.album}&quot;,&#10;                        style = MaterialTheme.typography.body2,&#10;                        color = MaterialTheme.colors.onBackground.copy(alpha = 0.5f),&#10;                        maxLines = 1,&#10;                        overflow = TextOverflow.Ellipsis&#10;                    )&#10;                }&#10;            }&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/kotlin/com/example/musicplayer/ui/screens/MainScreen.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/kotlin/com/example/musicplayer/ui/screens/MainScreen.kt" />
              <option name="originalContent" value="package com.example.musicplayer.ui.screens&#10;&#10;import androidx.compose.foundation.background&#10;import androidx.compose.foundation.layout.*&#10;import androidx.compose.material.*&#10;import androidx.compose.runtime.*&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.graphics.Color&#10;import androidx.compose.ui.unit.dp&#10;import com.example.musicplayer.AppState&#10;import com.example.musicplayer.Screen&#10;import com.example.musicplayer.ui.components.BottomPlayerBar&#10;import com.example.musicplayer.ui.components.TopBar&#10;&#10;@Composable&#10;fun MainScreen(appState: AppState) {&#10;    var currentScreen by remember { mutableStateOf&lt;Screen&gt;(Screen.Library) }&#10;    val currentTrack by appState.currentTrack.collectAsState()&#10;    val isPlaying by appState.isPlaying.collectAsState()&#10;    &#10;    Scaffold(&#10;        topBar = {&#10;            TopBar(&#10;                currentScreen = currentScreen,&#10;                onNavigationClick = { screen -&gt;&#10;                    currentScreen = screen&#10;                }&#10;            )&#10;        },&#10;        bottomBar = {&#10;            currentTrack?.let { track -&gt;&#10;                BottomPlayerBar(&#10;                    track = track,&#10;                    isPlaying = isPlaying,&#10;                    onPlayPauseClick = { appState.playPause() },&#10;                    modifier = Modifier.fillMaxWidth()&#10;                )&#10;            }&#10;        }&#10;    ) { padding -&gt;&#10;        Box(&#10;            modifier = Modifier&#10;                .fillMaxSize()&#10;                .padding(padding)&#10;                .background(MaterialTheme.colors.background)&#10;        ) {&#10;            when (currentScreen) {&#10;                is Screen.Player -&gt; PlayerScreen(&#10;                    currentTrack = currentTrack,&#10;                    isPlaying = isPlaying,&#10;                    onPlayPauseClick = { appState.playPause() },&#10;                    onPreviousClick = { appState.playPreviousTrack() },&#10;                    onNextClick = { appState.playNextTrack() }&#10;                )&#10;                is Screen.Search -&gt; SearchScreen(&#10;                    availableTracks = appState.trackList.collectAsState().value,&#10;                    onTrackSelected = { track -&gt;&#10;                        appState.selectTrack(track)&#10;                    }&#10;                )&#10;                is Screen.Library -&gt; LibraryScreen()&#10;                is Screen.Settings -&gt; SettingsScreen()&#10;            }&#10;        }&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.example.musicplayer.ui.screens&#10;&#10;import androidx.compose.foundation.background&#10;import androidx.compose.foundation.layout.*&#10;import androidx.compose.material.*&#10;import androidx.compose.runtime.*&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.graphics.Color&#10;import androidx.compose.ui.unit.dp&#10;import com.example.musicplayer.AppState&#10;import com.example.musicplayer.Screen&#10;import com.example.musicplayer.ui.components.BottomPlayerBar&#10;import com.example.musicplayer.ui.components.TopBar&#10;&#10;@Composable&#10;fun MainScreen(appState: AppState) {&#10;    var currentScreen by remember { mutableStateOf&lt;Screen&gt;(Screen.Library) }&#10;    val currentTrack by appState.currentTrack.collectAsState()&#10;    val isPlaying by appState.isPlaying.collectAsState()&#10;    &#10;    Scaffold(&#10;        topBar = {&#10;            TopBar(&#10;                currentScreen = currentScreen,&#10;                onNavigationClick = { screen -&gt;&#10;                    currentScreen = screen&#10;                }&#10;            )&#10;        },&#10;        bottomBar = {&#10;            currentTrack?.let { track -&gt;&#10;                BottomPlayerBar(&#10;                    track = track,&#10;                    isPlaying = isPlaying,&#10;                    onPlayPauseClick = { appState.playPause() },&#10;                    modifier = Modifier.fillMaxWidth()&#10;                )&#10;            }&#10;        }&#10;    ) { padding -&gt;&#10;        Box(&#10;            modifier = Modifier&#10;                .fillMaxSize()&#10;                .padding(padding)&#10;                .background(MaterialTheme.colors.background)&#10;        ) {&#10;            when (currentScreen) {&#10;                is Screen.Player -&gt; PlayerScreen(&#10;                    currentTrack = currentTrack,&#10;                    isPlaying = isPlaying,&#10;                    onPlayPauseClick = { appState.playPause() },&#10;                    onPreviousClick = { appState.playPreviousTrack() },&#10;                    onNextClick = { appState.playNextTrack() },&#10;                    appState = appState&#10;                )&#10;                is Screen.Search -&gt; SearchScreen(&#10;                    availableTracks = appState.trackList.collectAsState().value,&#10;                    onTrackSelected = { track -&gt;&#10;                        appState.selectTrack(track)&#10;                    }&#10;                )&#10;                is Screen.Library -&gt; LibraryScreen()&#10;                is Screen.Settings -&gt; SettingsScreen()&#10;            }&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/kotlin/com/example/musicplayer/ui/screens/PlayerScreen.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/kotlin/com/example/musicplayer/ui/screens/PlayerScreen.kt" />
              <option name="originalContent" value="package com.example.musicplayer.ui.screens&#10;&#10;import androidx.compose.foundation.background&#10;import androidx.compose.foundation.layout.*&#10;import androidx.compose.foundation.shape.CircleShape&#10;import androidx.compose.material.*&#10;import androidx.compose.material.icons.Icons&#10;import androidx.compose.material.icons.filled.Pause&#10;import androidx.compose.material.icons.filled.PlayArrow&#10;import androidx.compose.material.icons.filled.SkipNext&#10;import androidx.compose.material.icons.filled.SkipPrevious&#10;import androidx.compose.runtime.*&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.draw.clip&#10;import androidx.compose.ui.graphics.Color&#10;import androidx.compose.ui.unit.dp&#10;import com.example.musicplayer.MusicTrack&#10;import com.example.musicplayer.ui.components.AlbumCover&#10;import com.example.musicplayer.ui.components.PlaybackProgressBar&#10;&#10;@Composable&#10;fun PlayerScreen(&#10;    currentTrack: MusicTrack?,&#10;    isPlaying: Boolean,&#10;    onPlayPauseClick: () -&gt; Unit,&#10;    onPreviousClick: () -&gt; Unit,&#10;    onNextClick: () -&gt; Unit&#10;) {&#10;    var currentPosition by remember { mutableStateOf(0f) }&#10;    val duration = currentTrack?.duration?.div(1000f) ?: 0f // мс -&gt; секунды&#10;&#10;    Column(&#10;        modifier = Modifier&#10;            .fillMaxSize()&#10;            .padding(16.dp),&#10;        horizontalAlignment = Alignment.CenterHorizontally,&#10;        verticalArrangement = Arrangement.Center&#10;    ) {&#10;        currentTrack?.let { track -&gt;&#10;            AlbumCover(&#10;                track = track,&#10;                modifier = Modifier&#10;                    .fillMaxWidth(0.8f)&#10;                    .aspectRatio(1f)&#10;            )&#10;&#10;            Spacer(modifier = Modifier.height(32.dp))&#10;&#10;            Column(&#10;                horizontalAlignment = Alignment.CenterHorizontally&#10;            ) {&#10;                Text(&#10;                    text = track.title,&#10;                    style = MaterialTheme.typography.h5,&#10;                    color = MaterialTheme.colors.onBackground&#10;                )&#10;&#10;                Spacer(modifier = Modifier.height(4.dp))&#10;&#10;                Text(&#10;                    text = track.artist,&#10;                    style = MaterialTheme.typography.subtitle1,&#10;                    color = MaterialTheme.colors.onBackground.copy(alpha = 0.7f)&#10;                )&#10;&#10;                Spacer(modifier = Modifier.height(8.dp))&#10;&#10;                Text(&#10;                    text = track.album,&#10;                    style = MaterialTheme.typography.body2,&#10;                    color = MaterialTheme.colors.onBackground.copy(alpha = 0.6f)&#10;                )&#10;            }&#10;&#10;            Spacer(modifier = Modifier.height(24.dp))&#10;&#10;            PlaybackProgressBar(&#10;                currentPosition = currentPosition,&#10;                duration = duration,&#10;                onPositionChange = { newPosition -&gt;&#10;                    currentPosition = newPosition.coerceIn(0f, duration)&#10;                }&#10;            )&#10;&#10;            Spacer(modifier = Modifier.height(24.dp))&#10;&#10;            Row(&#10;                verticalAlignment = Alignment.CenterVertically,&#10;                horizontalArrangement = Arrangement.spacedBy(16.dp)&#10;            ) {&#10;                IconButton(onClick = onPreviousClick) {&#10;                    Icon(&#10;                        imageVector = Icons.Default.SkipPrevious,&#10;                        contentDescription = &quot;Previous track&quot;,&#10;                        modifier = Modifier.size(32.dp),&#10;                    )&#10;                }&#10;&#10;                IconButton(&#10;                    onClick = onPlayPauseClick,&#10;                    modifier = Modifier&#10;                        .size(64.dp)&#10;                        .clip(CircleShape)&#10;                        .background(MaterialTheme.colors.primary)&#10;                ) {&#10;                    Icon(&#10;                        imageVector = if (isPlaying) Icons.Default.Pause else Icons.Default.PlayArrow,&#10;                        contentDescription = if (isPlaying) &quot;Pause&quot; else &quot;Play&quot;,&#10;                        tint = Color.White,&#10;                        modifier = Modifier.size(32.dp)&#10;                    )&#10;                }&#10;&#10;                IconButton(onClick = onNextClick) {&#10;                    Icon(&#10;                        imageVector = Icons.Default.SkipNext,&#10;                        contentDescription = &quot;Next track&quot;,&#10;                        modifier = Modifier.size(32.dp),&#10;                    )&#10;                }&#10;            }&#10;            } ?: run {&#10;                Text(&#10;                    text = &quot;No track selected&quot;,&#10;                    style = MaterialTheme.typography.h6,&#10;                    color = MaterialTheme.colors.onBackground.copy(alpha = 0.6f),&#10;                )&#10;            }&#10;        }&#10;    }" />
              <option name="updatedContent" value="package com.example.musicplayer.ui.screens&#10;&#10;import androidx.compose.foundation.background&#10;import androidx.compose.foundation.layout.*&#10;import androidx.compose.foundation.shape.CircleShape&#10;import androidx.compose.material.*&#10;import androidx.compose.material.icons.Icons&#10;import androidx.compose.material.icons.filled.Pause&#10;import androidx.compose.material.icons.filled.PlayArrow&#10;import androidx.compose.material.icons.filled.SkipNext&#10;import androidx.compose.material.icons.filled.SkipPrevious&#10;import androidx.compose.runtime.*&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.draw.clip&#10;import androidx.compose.ui.graphics.Color&#10;import androidx.compose.ui.unit.dp&#10;import com.example.musicplayer.AppState&#10;import com.example.musicplayer.MusicTrack&#10;import com.example.musicplayer.ui.components.AlbumCover&#10;import com.example.musicplayer.ui.components.PlaybackProgressBar&#10;&#10;@Composable&#10;fun PlayerScreen(&#10;    currentTrack: MusicTrack?,&#10;    isPlaying: Boolean,&#10;    onPlayPauseClick: () -&gt; Unit,&#10;    onPreviousClick: () -&gt; Unit,&#10;    onNextClick: () -&gt; Unit,&#10;    appState: AppState? = null&#10;) {&#10;    // Получаем реальные данные от MP3 плеера если доступны&#10;    val playerPosition by (appState?.playerPosition?.collectAsState() ?: remember { mutableStateOf(0L) })&#10;    val playerDuration by (appState?.playerDuration?.collectAsState() ?: remember { mutableStateOf(0L) })&#10;&#10;    // Используем данные плеера или fallback значения&#10;    val currentPositionSec = (playerPosition / 1000f).coerceAtLeast(0f)&#10;    val durationSec = if (playerDuration &gt; 0) (playerDuration / 1000f) else (currentTrack?.duration?.div(1000f) ?: 0f)&#10;&#10;    Column(&#10;        modifier = Modifier&#10;            .fillMaxSize()&#10;            .padding(16.dp),&#10;        horizontalAlignment = Alignment.CenterHorizontally,&#10;        verticalArrangement = Arrangement.Center&#10;    ) {&#10;        currentTrack?.let { track -&gt;&#10;            AlbumCover(&#10;                track = track,&#10;                modifier = Modifier&#10;                    .fillMaxWidth(0.8f)&#10;                    .aspectRatio(1f)&#10;            )&#10;&#10;            Spacer(modifier = Modifier.height(32.dp))&#10;&#10;            Column(&#10;                horizontalAlignment = Alignment.CenterHorizontally&#10;            ) {&#10;                Text(&#10;                    text = track.title,&#10;                    style = MaterialTheme.typography.h5,&#10;                    color = MaterialTheme.colors.onBackground&#10;                )&#10;&#10;                Spacer(modifier = Modifier.height(4.dp))&#10;&#10;                Text(&#10;                    text = track.artist,&#10;                    style = MaterialTheme.typography.subtitle1,&#10;                    color = MaterialTheme.colors.onBackground.copy(alpha = 0.7f)&#10;                )&#10;&#10;                Spacer(modifier = Modifier.height(8.dp))&#10;&#10;                Text(&#10;                    text = track.album,&#10;                    style = MaterialTheme.typography.body2,&#10;                    color = MaterialTheme.colors.onBackground.copy(alpha = 0.6f)&#10;                )&#10;            }&#10;&#10;            Spacer(modifier = Modifier.height(24.dp))&#10;&#10;            PlaybackProgressBar(&#10;                currentPosition = currentPositionSec,&#10;                duration = durationSec,&#10;                onPositionChange = { /* Обновление UI происходит автоматически */ },&#10;                onSeek = { newPositionSec -&gt;&#10;                    // Перемотка только для MP3 треков&#10;                    if (track.filePath.startsWith(&quot;http&quot;) || track.filePath.lowercase().endsWith(&quot;.mp3&quot;)) {&#10;                        appState?.seekTo((newPositionSec * 1000).toLong())&#10;                    }&#10;                }&#10;            )&#10;&#10;            Spacer(modifier = Modifier.height(24.dp))&#10;&#10;            Row(&#10;                verticalAlignment = Alignment.CenterVertically,&#10;                horizontalArrangement = Arrangement.spacedBy(16.dp)&#10;            ) {&#10;                IconButton(onClick = onPreviousClick) {&#10;                    Icon(&#10;                        imageVector = Icons.Default.SkipPrevious,&#10;                        contentDescription = &quot;Previous track&quot;,&#10;                        modifier = Modifier.size(32.dp),&#10;                    )&#10;                }&#10;&#10;                IconButton(&#10;                    onClick = onPlayPauseClick,&#10;                    modifier = Modifier&#10;                        .size(64.dp)&#10;                        .clip(CircleShape)&#10;                        .background(MaterialTheme.colors.primary)&#10;                ) {&#10;                    Icon(&#10;                        imageVector = if (isPlaying) Icons.Default.Pause else Icons.Default.PlayArrow,&#10;                        contentDescription = if (isPlaying) &quot;Pause&quot; else &quot;Play&quot;,&#10;                        tint = Color.White,&#10;                        modifier = Modifier.size(32.dp)&#10;                    )&#10;                }&#10;&#10;                IconButton(onClick = onNextClick) {&#10;                    Icon(&#10;                        imageVector = Icons.Default.SkipNext,&#10;                        contentDescription = &quot;Next track&quot;,&#10;                        modifier = Modifier.size(32.dp),&#10;                    )&#10;                }&#10;            }&#10;        } ?: run {&#10;            Text(&#10;                text = &quot;No track selected&quot;,&#10;                style = MaterialTheme.typography.h6,&#10;                color = MaterialTheme.colors.onBackground.copy(alpha = 0.6f),&#10;            )&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/kotlin/com/example/musicplayer/ui/screens/SearchScreen.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/kotlin/com/example/musicplayer/ui/screens/SearchScreen.kt" />
              <option name="originalContent" value="package com.example.musicplayer.ui.screens&#10;&#10;import androidx.compose.foundation.layout.*&#10;import androidx.compose.foundation.lazy.LazyColumn&#10;import androidx.compose.foundation.lazy.items&#10;import androidx.compose.material.*&#10;import androidx.compose.material.icons.Icons&#10;import androidx.compose.material.icons.filled.Search&#10;import androidx.compose.runtime.*&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.unit.dp&#10;import com.example.musicplayer.MusicTrack&#10;import androidx.compose.foundation.clickable&#10;import androidx.compose.material.Card&#10;import com.example.musicplayer.data.itunes.ITunesApi&#10;import com.example.musicplayer.data.itunes.toAppMusicTrack&#10;import kotlinx.coroutines.Job&#10;import kotlinx.coroutines.delay&#10;import kotlinx.coroutines.launch&#10;&#10;@Composable&#10;fun TrackItem(&#10;    track: MusicTrack,&#10;    onClick: () -&gt; Unit&#10;) {&#10;    Card(&#10;        modifier = Modifier&#10;            .fillMaxWidth()&#10;            .padding(vertical = 4.dp)&#10;            .clickable { onClick() },&#10;        elevation = 2.dp&#10;    ) {&#10;        Column(&#10;            modifier = Modifier.padding(16.dp)&#10;        ) {&#10;            Text(&#10;                text = track.title,&#10;                style = MaterialTheme.typography.h6&#10;            )&#10;            Text(&#10;                text = track.artist,&#10;                style = MaterialTheme.typography.subtitle1,&#10;                color = MaterialTheme.colors.onSurface.copy(alpha = 0.6f)&#10;            )&#10;            if (track.album.isNotEmpty()) {&#10;                Text(&#10;                    text = track.album,&#10;                    style = MaterialTheme.typography.body2,&#10;                    color = MaterialTheme.colors.onSurface.copy(alpha = 0.4f)&#10;                )&#10;            }&#10;        }&#10;    }&#10;}&#10;&#10;@Composable&#10;fun SearchScreen(&#10;    availableTracks: List&lt;MusicTrack&gt; = emptyList(),&#10;    onTrackSelected: (MusicTrack) -&gt; Unit = {}&#10;) {&#10;    var searchQuery by remember { mutableStateOf(&quot;&quot;) }&#10;    var searchResults by remember { mutableStateOf&lt;List&lt;MusicTrack&gt;&gt;(emptyList()) }&#10;    var online by remember { mutableStateOf(true) }&#10;    var isLoading by remember { mutableStateOf(false) }&#10;    var error by remember { mutableStateOf&lt;String?&gt;(null) }&#10;    val scope = rememberCoroutineScope()&#10;    var debounceJob by remember { mutableStateOf&lt;Job?&gt;(null) }&#10;&#10;    Column(modifier = Modifier.fillMaxSize().padding(16.dp)) {&#10;        Row(Modifier.fillMaxWidth(), horizontalArrangement = Arrangement.spacedBy(8.dp)) {&#10;            OutlinedTextField(&#10;                value = searchQuery,&#10;                onValueChange = { newValue -&gt;&#10;                    searchQuery = newValue&#10;                    error = null&#10;                    debounceJob?.cancel()&#10;                    if (searchQuery.isBlank()) {&#10;                        searchResults = emptyList()&#10;                    } else {&#10;                        debounceJob = scope.launch {&#10;                            delay(400)&#10;                            if (online) {&#10;                                isLoading = true&#10;                                searchResults = runCatching {&#10;                                    ITunesApi.searchTracks(searchQuery).map { it.toAppMusicTrack() }&#10;                                }.onFailure { error = it.message }.getOrDefault(emptyList())&#10;                                isLoading = false&#10;                            } else {&#10;                                searchResults = availableTracks.filter { track -&gt;&#10;                                    track.title.contains(searchQuery, true) ||&#10;                                            track.artist.contains(searchQuery, true) ||&#10;                                            track.album.contains(searchQuery, true)&#10;                                }&#10;                            }&#10;                        }&#10;                    }&#10;                },&#10;                modifier = Modifier.weight(1f),&#10;                label = { Text(&quot;Search&quot;) },&#10;                leadingIcon = { Icon(Icons.Default.Search, contentDescription = &quot;Search&quot;) },&#10;                singleLine = true&#10;            )&#10;            Column(horizontalAlignment = Alignment.CenterHorizontally) {&#10;                Text(if (online) &quot;Online&quot; else &quot;Local&quot;, style = MaterialTheme.typography.caption)&#10;                Switch(checked = online, onCheckedChange = { checked -&gt;&#10;                    online = checked&#10;                    searchResults = emptyList()&#10;                    if (searchQuery.isNotBlank()) {&#10;                        // перезапустить поиск&#10;                        scope.launch {&#10;                            isLoading = true&#10;                            searchResults = if (online) {&#10;                                runCatching { ITunesApi.searchTracks(searchQuery).map { it.toAppMusicTrack() } }&#10;                                    .onFailure { error = it.message }&#10;                                    .getOrDefault(emptyList())&#10;                            } else {&#10;                                availableTracks.filter { track -&gt;&#10;                                    track.title.contains(searchQuery, true) ||&#10;                                            track.artist.contains(searchQuery, true) ||&#10;                                            track.album.contains(searchQuery, true)&#10;                                }&#10;                            }&#10;                            isLoading = false&#10;                        }&#10;                    }&#10;                })&#10;            }&#10;        }&#10;&#10;        if (isLoading) {&#10;            LinearProgressIndicator(modifier = Modifier.fillMaxWidth().padding(top = 8.dp))&#10;        }&#10;        error?.let {&#10;            Text(it, color = MaterialTheme.colors.error, style = MaterialTheme.typography.caption)&#10;        }&#10;&#10;        Spacer(modifier = Modifier.height(16.dp))&#10;&#10;        LazyColumn {&#10;            items(searchResults) { track -&gt;&#10;                TrackItem(&#10;                    track = track,&#10;                    onClick = { onTrackSelected(track) }&#10;                )&#10;                Divider()&#10;            }&#10;        }&#10;    }&#10;}" />
              <option name="updatedContent" value="package com.example.musicplayer.ui.screens&#10;&#10;import androidx.compose.foundation.layout.*&#10;import androidx.compose.foundation.lazy.LazyColumn&#10;import androidx.compose.foundation.lazy.items&#10;import androidx.compose.material.*&#10;import androidx.compose.material.icons.Icons&#10;import androidx.compose.material.icons.filled.Search&#10;import androidx.compose.runtime.*&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.unit.dp&#10;import com.example.musicplayer.MusicTrack&#10;import androidx.compose.foundation.clickable&#10;import androidx.compose.material.Card&#10;import com.example.musicplayer.data.deezer.DeezerApi&#10;import com.example.musicplayer.data.deezer.toAppMusicTrack&#10;import kotlinx.coroutines.Job&#10;import kotlinx.coroutines.delay&#10;import kotlinx.coroutines.launch&#10;&#10;@Composable&#10;fun TrackItem(&#10;    track: MusicTrack,&#10;    onClick: () -&gt; Unit&#10;) {&#10;    Card(&#10;        modifier = Modifier&#10;            .fillMaxWidth()&#10;            .padding(vertical = 4.dp)&#10;            .clickable { onClick() },&#10;        elevation = 2.dp&#10;    ) {&#10;        Column(&#10;            modifier = Modifier.padding(16.dp)&#10;        ) {&#10;            Text(&#10;                text = track.title,&#10;                style = MaterialTheme.typography.h6&#10;            )&#10;            Text(&#10;                text = track.artist,&#10;                style = MaterialTheme.typography.subtitle1,&#10;                color = MaterialTheme.colors.onSurface.copy(alpha = 0.6f)&#10;            )&#10;            if (track.album.isNotEmpty()) {&#10;                Text(&#10;                    text = track.album,&#10;                    style = MaterialTheme.typography.body2,&#10;                    color = MaterialTheme.colors.onSurface.copy(alpha = 0.4f)&#10;                )&#10;            }&#10;        }&#10;    }&#10;}&#10;&#10;@Composable&#10;fun SearchScreen(&#10;    availableTracks: List&lt;MusicTrack&gt; = emptyList(),&#10;    onTrackSelected: (MusicTrack) -&gt; Unit = {}&#10;) {&#10;    var searchQuery by remember { mutableStateOf(&quot;&quot;) }&#10;    var searchResults by remember { mutableStateOf&lt;List&lt;MusicTrack&gt;&gt;(emptyList()) }&#10;    var online by remember { mutableStateOf(true) }&#10;    var isLoading by remember { mutableStateOf(false) }&#10;    var error by remember { mutableStateOf&lt;String?&gt;(null) }&#10;    val scope = rememberCoroutineScope()&#10;    var debounceJob by remember { mutableStateOf&lt;Job?&gt;(null) }&#10;&#10;    Column(modifier = Modifier.fillMaxSize().padding(16.dp)) {&#10;        Row(Modifier.fillMaxWidth(), horizontalArrangement = Arrangement.spacedBy(8.dp)) {&#10;            OutlinedTextField(&#10;                value = searchQuery,&#10;                onValueChange = { newValue -&gt;&#10;                    searchQuery = newValue&#10;                    error = null&#10;                    debounceJob?.cancel()&#10;                    if (searchQuery.isBlank()) {&#10;                        searchResults = emptyList()&#10;                    } else {&#10;                        debounceJob = scope.launch {&#10;                            delay(400)&#10;                            if (online) {&#10;                                isLoading = true&#10;                                searchResults = runCatching {&#10;                                    DeezerApi.searchTracks(searchQuery).map { it.toAppMusicTrack() }&#10;                                }.onFailure { error = it.message }.getOrDefault(emptyList())&#10;                                isLoading = false&#10;                            } else {&#10;                                searchResults = availableTracks.filter { track -&gt;&#10;                                    track.title.contains(searchQuery, true) ||&#10;                                            track.artist.contains(searchQuery, true) ||&#10;                                            track.album.contains(searchQuery, true)&#10;                                }&#10;                            }&#10;                        }&#10;                    }&#10;                },&#10;                modifier = Modifier.weight(1f),&#10;                label = { Text(&quot;Search&quot;) },&#10;                leadingIcon = { Icon(Icons.Default.Search, contentDescription = &quot;Search&quot;) },&#10;                singleLine = true&#10;            )&#10;            Column(horizontalAlignment = Alignment.CenterHorizontally) {&#10;                Text(if (online) &quot;Online&quot; else &quot;Local&quot;, style = MaterialTheme.typography.caption)&#10;                Switch(checked = online, onCheckedChange = { checked -&gt;&#10;                    online = checked&#10;                    searchResults = emptyList()&#10;                    if (searchQuery.isNotBlank()) {&#10;                        // перезапустить поиск&#10;                        scope.launch {&#10;                            isLoading = true&#10;                            searchResults = if (online) {&#10;                                runCatching { DeezerApi.searchTracks(searchQuery).map { it.toAppMusicTrack() } }&#10;                                    .onFailure { error = it.message }&#10;                                    .getOrDefault(emptyList())&#10;                            } else {&#10;                                availableTracks.filter { track -&gt;&#10;                                    track.title.contains(searchQuery, true) ||&#10;                                            track.artist.contains(searchQuery, true) ||&#10;                                            track.album.contains(searchQuery, true)&#10;                                }&#10;                            }&#10;                            isLoading = false&#10;                        }&#10;                    }&#10;                })&#10;            }&#10;        }&#10;&#10;        if (isLoading) {&#10;            LinearProgressIndicator(modifier = Modifier.fillMaxWidth().padding(top = 8.dp))&#10;        }&#10;        error?.let {&#10;            Text(it, color = MaterialTheme.colors.error, style = MaterialTheme.typography.caption)&#10;        }&#10;&#10;        Spacer(modifier = Modifier.height(16.dp))&#10;&#10;        LazyColumn {&#10;            items(searchResults) { track -&gt;&#10;                TrackItem(&#10;                    track = track,&#10;                    onClick = { onTrackSelected(track) }&#10;                )&#10;                Divider()&#10;            }&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>